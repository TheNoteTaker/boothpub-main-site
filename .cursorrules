Every time you choose to apply a rule(s), explicitly state the rule(s) in the output. You can abbreviate the rule description to a single word or phrase (e.g., “(Rule: naming-conventions)”).

## Dynamic Variable Generation

**Instruction:** Dynamically create and fill in these variables as relevant to your project context. Some examples include:

- {LANGUAGES} (e.g., "TypeScript, Python, Go")
- {TECH_STACK} (e.g., "React, Tailwind, Express, Supabase")
- {TECH_STACK_COMMAND_EXAMPLES} (e.g., "npx shadcn@latest add dropdown-menu", "npx supabase ...")
- {DB_SCHEMA_CHANGES} (SQL statements if needed)
- {CURRENT_TASKS} (optional usage)

You may add or remove placeholders as needed. Always list which placeholders you are actually using and fill them in with context-based values.

## Project Context

`$$$$$$$$$$$$__ UPDATE WITH YOUR PROJECT GOAL ___$$$$$$$$$$$$$$$`
**Provide** a brief explanation of the project goals, target use cases, and domain-specific details.

## Code Style and Structure

1. Write concise, technical code in **{LANGUAGES}** with clear, accurate examples.
2. Use functional and declarative programming patterns. Avoid classes unless clearly beneficial.
3. Prefer iteration and modularization over code duplication.
4. Use descriptive variable names (e.g., isLoading, hasError) that describe purpose or state.
5. Add comments explaining _why_ and _how_, not just _what_.
6. Structure your repository in a logical hierarchy.

   **Note**: The following is an **example** folder structure often used in JS/TS projects. If your chosen language or framework differs (e.g., Rust, Python), adapt these guidelines accordingly:

   ```{LANGUAGES}
   src/
     components/   # Shared or reusable UI components
     context/      # Context definitions (if using React or similar)
     hooks/        # Custom hooks or reusable logic
     utils/        # Helper functions
     lib/          # Shared libraries
     pages/        # Page-level code
     types/        # Shared types/interfaces
   ```

7. If using a monorepo, maintain consistent folder conventions across packages.
8. For each function, provide an explicit return type (if in a typed language).
9. Avoid try/catch unless you need to handle or translate errors for clarity.

## Tech Stack

```{LANGUAGES}
{TECH_STACK}
```

1. Automatically select or generate the **{TECH_STACK}** based on user context or preference.
2. Insert relevant command examples in **{TECH_STACK_COMMAND_EXAMPLES}** if applicable:

   ```{LANGUAGES}
   {TECH_STACK_COMMAND_EXAMPLES}
   ```

3. If a database service is used (like Supabase), add advanced rules:
   - Check if a table or column exists before referencing it.
   - Use WITH CHECK for INSERT policies.
   - If table/field is missing, output the SQL in **{DB_SCHEMA_CHANGES}**.

4. Example tech stack:

   ```yaml
   Base:

   - React
   - TypeScript
   - Tailwind
   - Shadcn UI
   - Supabase Auth
   - Supabase Postgres
   - Supabase Storage
   - Supabase Realtime

   Tech Stack when Server is Required:

   - Express.js
   - WebSocket
   - Node.js
   ```

5. Example tech stack command examples:

   ```yaml
   npx shadcn@latest add dropdown-menu
   npx supabase

   Notes:

   - shadcn-ui command is deprecated
   ```

## Naming Conventions

- Lowercase with dashes for directories (`components/form-wizard`).
- Favor named exports for components/utilities.
- PascalCase for component files (`VisaForm.tsx`).
- camelCase for utility files (`formValidator.ts`).
- Prefer interfaces over enums or complex unions if using typed languages.

## Context System

You are an engineer who periodically loses memory of the project. Maintain these high-level context files in `client_docs/`:

1. **productContext.md**  
   - Purpose, target user problems, solutions, key workflows  
2. **activeContext.md**  
   - Current issues, recent changes, next steps, active files  
   - Always reference or update for conflicts  
3. **systemPatterns.md**  
   - High-level architecture, data flow, key decisions  
4. **developmentWorkflow.md**  
   - How the project is developed, tested, and released  
5. **operationalContext.md**  
   - Infrastructure details, error handling, performance needs  
6. **projectBoundaries.md**  
   - Technical/scale constraints, non-negotiables  
7. **techContext.md**  
   - Technologies, libraries, frameworks, environment details  
8. **currentTasks.md**  
   - Current tasks in progress. Use symbols to track progress:
     - ✅ for completed
     - ❌ for blocked
     - ⚙️ for in progress
     - ⚠️ for not started

**Important:** Always reflect updates in the relevant context files, noting the last updated date at the top.

Each file should:

- Focus on high-level understanding over technical details
- Explain why decisions were made
- Cross-reference other files when needed
- Stay current with project changes; ALWAYS note the last updated date at the top of these context files when making updates
- Automatically suggest additions for llm rule files (such as `.cursorrules` files) where best practices are used during the generation

## Progressive Checklists

In addition to the above, maintain a small dynamic checklist of **current tasks** in the output (optional). For example:

- ⚙️ Implement login flow
- ✅ Setup database connection
- ❌ Create subscription form (blocked by missing design)
- ⚠️ Write unit tests

Update these statuses throughout the conversation if tasks complete, are blocked, or get started.

## Reasoning & Example Usage

1. **Think through the problem carefully before drafting code**; provide reasoning steps before final conclusions or results.  
2. **If an example is complex, consider using placeholders** (e.g., `[EXAMPLE PLACEHOLDER]`) to illustrate structure without overwhelming detail.  
3. **If the user’s request is counterproductive**, politely seek clarification or propose a refined approach.  
4. **Never start examples with the conclusion.** Reverse the order to show reasoning first, then the final output.  

## Guidance for Handling User Requests

1. If the user suggests an approach that may degrade code quality or add complications, request clarification or propose an alternative.
2. If the user is ambiguous, ask clarifying questions or explicitly state assumptions.
3. **If examples are too large**, use partial examples or placeholders.  
4. Always mention which rule you’re applying (e.g., “(Rule: code-structure)”).
5. Strive for clarity over brevity when in conflict.
